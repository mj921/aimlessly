<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>贪吃蛇</title>
    <style>
      body,
      div,
      dl,
      dt {
        padding: 0;
        margin: 0;
      }
      #main {
        margin: 0 auto;
        width: 750px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      button {
        display: block;
        margin: 10px 0;
        width: 80px;
      }
      #panel {
        width: 500px;
        height: 500px;
        border: 1px solid #000;
        box-sizing: content-box;
      }
    </style>
  </head>
  <body>
    <div id="main">
      <button onclick="panel.init()">重新开始</button>
      <canvas id="panel" width="500" height="500"></canvas>
    </div>
    <script>
      const Cell = function (x, y, ele) {
        this.x = x;
        this.y = y;
        this.ele = ele;
        this.status = 0; // -1食物 0 空 1 蛇
      };
      //面板对象
      const panel = {
        snake: null,
        cells: [],
        width: 500,
        height: 500,
        cellSize: 50,
        obj: document.getElementById('panel'),
        ctx: document.getElementById('panel').getContext('2d'),
        food: {},
        rows: 10, //行数
        cols: 10,
        time: 1000, //自动移动个间隔时间
        sto: null, //移动定时器
        dirStatus: true, //能否转向状态 (一次移动只能转一次)
        //创建格子
        createCells: function () {
          this.cells = [];
          for (let i = 0; i < this.rows; i++) {
            const cs = [];
            for (let j = 0; j < this.cols; j++) {
              cs[cs.length] = { x: j, y: i, status: 0 };
            }
            this.cells[this.cells.length] = cs;
          }
        },
        //重置面板状态
        resetStatus: function () {
          this.createCells();
        },
        //创建食物
        createFood: function () {
          let rd = ~~(Math.random() * this.cols * this.rows);
          while (this.cells[~~(rd / this.cols)][rd % this.rows].status !== 0) {
            rd = ~~(Math.random() * this.cols * this.rows);
          }
          const x = rd % this.rows,
            y = ~~(rd / this.cols);
          this.food = { x, y };
          this.cells[y][x].status = -1;
        },
        // 判断是否越界
        isCrossTheBorder: function () {
          const { x, y } = this.snake.body[0];
          return x < 0 || x > this.cols - 1 || y < 0 || y > this.rows - 1;
        },
        //判断蛇是撞到自己
        isDeath: function () {
          return (
            this.cells[this.snake.body[0].x][this.snake.body[0].y].status > 1
          );
        },
        //自动移动
        autoMove: function () {
          this.ctx.clearRect(0, 0, this.width, this.height);
          this.dirStatus = true;
          this.snake.forEach(({ x, y }) => {
            this.cells[y][x].status = 0;
          });
          const eatFlag = this.snake.move(this.food);
          if (this.isCrossTheBorder()) {
            alert('游戏结束');
            clearTimeout(this.sto);
            return;
          }
          this.ctx.fillStyle = '#123456';
          this.snake.forEach(({ x, y }) => {
            this.cells[y][x].status++;
            this.ctx.fillRect(
              x * this.cellSize,
              y * this.cellSize,
              this.cellSize,
              this.cellSize
            );
          });
          if (eatFlag) {
            this.createFood();
          }
          this.ctx.fillStyle = '#fe1234';
          this.ctx.fillRect(
            this.food.x * this.cellSize,
            this.food.y * this.cellSize,
            this.cellSize,
            this.cellSize
          );
          if (this.isDeath()) {
            alert('游戏结束');
            clearTimeout(sto);
          } else {
            this.sto = setTimeout(() => {
              this.autoMove();
            }, this.time);
          }
        },
        //开始键盘监听
        startKeyLinster: function () {
          document.addEventListener('keyup', (e) => {
            if (e.keyCode >= 37 && e.keyCode <= 40 && this.dirStatus) {
              this.dirStatus = !this.snake.turnTo(e.keyCode - 37);
            }
          });
        },
        //初始化
        init: function () {
          this.obj.innerHTML = '';
          this.snake = new Snake({
            x: Math.floor(this.cols / 2),
            y: Math.floor(this.rows / 2),
          });
          this.createCells();
          this.createFood();
          this.autoMove();
          this.startKeyLinster();
        },
      };
      //蛇
      const Snake = function (head) {
        this.body = [head];
        this.dx = -1;
        this.dy = 0;
        this.length = 1;
      };
      //判断是否吃到食物
      Snake.prototype.isEat = function (food) {
        return (
          this.body[0].x + this.dx === food.x &&
          this.body[0].y + this.dy === food.y
        );
      };
      //蛇移动
      Snake.prototype.move = function (food) {
        if (this.isEat(food)) {
          this.length++;
          this.body.unshift({ x: food.x, y: food.y });
          return true;
        } else {
          this.body.unshift({
            x: this.body[0].x + this.dx,
            y: this.body[0].y + this.dy,
          });
          this.body.pop();
          return false;
        }
      };
      //转向 return 是否返回成功
      Snake.prototype.turnTo = function (d) {
        if ((this.dy === 0 && d % 2 === 1) || (this.dx === 0 && d % 2 === 0)) {
          if (this.dy === 0) {
            this.dx = 0;
            this.dy = d - 2;
          } else {
            this.dy = 0;
            this.dx = d - 1;
          }
          return true;
        }
        return false;
      };
      //遍历蛇执行方法
      Snake.prototype.forEach = function (callback) {
        for (let i = 0; i < this.length; i++) {
          callback(this.body[i]);
        }
      };

      panel.init();
    </script>
  </body>
</html>
