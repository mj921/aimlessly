<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      .btns {
        position: absolute;
        top: 0;
        right: 0;
        opacity: 0.5;
        background-color: #fff;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div class="btns">
      <button id="btn">开始</button>
      <button id="step">下一周期</button>
    </div>
    <script>
      const canvas = document.getElementById('canvas');
      const btn = document.getElementById('btn');
      const step = document.getElementById('step');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const ctx = canvas.getContext('2d');
      const baseSize = 64;
      let scale = 1;
      let cellSize = baseSize * Math.pow(2, scale - 1); // 每个细胞的大小
      const rows = Math.floor(canvas.height / cellSize); // 行数
      const cols = Math.floor(canvas.width / cellSize); // 列数
      let cellList = {};
      let deadCell = {};
      let translateX = 0;
      let translateY = 0;
      const createDeadCell = (i, j, value = 1) => {
        if (!cellList[`${i - 1},${j - 1}`]) {
          deadCell[`${i - 1},${j - 1}`] =
            (deadCell[`${i - 1},${j - 1}`] || 0) + value;
          if (deadCell[`${i - 1},${j - 1}`] <= 0) {
            delete deadCell[`${i - 1},${j - 1}`];
          }
        }
        if (!cellList[`${i - 1},${j}`]) {
          deadCell[`${i - 1},${j}`] = (deadCell[`${i - 1},${j}`] || 0) + value;
          if (deadCell[`${i - 1},${j}`] <= 0) {
            delete deadCell[`${i - 1},${j}`];
          }
        }
        if (!cellList[`${i - 1},${j + 1}`]) {
          deadCell[`${i - 1},${j + 1}`] =
            (deadCell[`${i - 1},${j + 1}`] || 0) + value;
          if (deadCell[`${i - 1},${j + 1}`] <= 0) {
            delete deadCell[`${i - 1},${j + 1}`];
          }
        }
        if (!cellList[`${i},${j - 1}`]) {
          deadCell[`${i},${j - 1}`] = (deadCell[`${i},${j - 1}`] || 0) + value;
          if (deadCell[`${i},${j - 1}`] <= 0) {
            delete deadCell[`${i},${j - 1}`];
          }
        }
        if (!cellList[`${i},${j + 1}`]) {
          deadCell[`${i},${j + 1}`] = (deadCell[`${i},${j + 1}`] || 0) + value;
          if (deadCell[`${i},${j + 1}`] <= 0) {
            delete deadCell[`${i},${j + 1}`];
          }
        }
        if (!cellList[`${i + 1},${j - 1}`]) {
          deadCell[`${i + 1},${j - 1}`] =
            (deadCell[`${i + 1},${j - 1}`] || 0) + value;
          if (deadCell[`${i + 1},${j - 1}`] <= 0) {
            delete deadCell[`${i + 1},${j - 1}`];
          }
        }
        if (!cellList[`${i + 1},${j}`]) {
          deadCell[`${i + 1},${j}`] = (deadCell[`${i + 1},${j}`] || 0) + value;
          if (deadCell[`${i + 1},${j}`] <= 0) {
            delete deadCell[`${i + 1},${j}`];
          }
        }
        if (!cellList[`${i + 1},${j + 1}`]) {
          deadCell[`${i + 1},${j + 1}`] =
            (deadCell[`${i + 1},${j + 1}`] || 0) + value;
          if (deadCell[`${i + 1},${j + 1}`] <= 0) {
            delete deadCell[`${i + 1},${j + 1}`];
          }
        }
      };

      const createDeadCells = () => {
        deadCell = {};
        Object.keys(cellList).forEach((key) => {
          const { i, j } = cellList[key];
          createDeadCell(i, j);
        });
      };
      // 创建一个二维数组来表示生命游戏的棋盘

      const createRandom = () => {
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (Math.random() > 0.5) {
              const key = `${i},${j}`;
              cellList[key] = { i, j };
            }
          }
        }
        createDeadCells();
      };

      // 绘制棋盘
      function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // 清除画布
        ctx.save();
        const currScale = Math.pow(2, scale - 1);
        ctx.scale(currScale, currScale);
        ctx.translate(translateX, translateY);
        const rowNum = Math.floor(canvas.height / cellSize); // 行数
        const cols = Math.floor(canvas.width / cellSize); // 列数
        if (scale > -3) {
          for (
            let i = -cellSize;
            i < (canvas.height + cellSize) / currScale;
            i += cellSize
          ) {
            ctx.beginPath();
            ctx.moveTo(-translateX, -translateY + i + (translateY % cellSize));
            ctx.lineTo(
              -translateX + canvas.width / currScale,
              -translateY + i + (translateY % cellSize)
            );
            ctx.stroke();
          }
          for (
            let i = -cellSize;
            i < (canvas.width + cellSize) / currScale;
            i += cellSize
          ) {
            ctx.beginPath();
            ctx.moveTo(-translateX + i + (translateX % cellSize), -translateY);
            ctx.lineTo(
              -translateX + i + (translateX % cellSize),
              -translateY + canvas.height / currScale
            );
            ctx.stroke();
          }
        }
        Object.keys(cellList).forEach((key) => {
          const { i, j } = cellList[key];
          ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
        });
        ctx.restore();
      }

      // 计算细胞下一代的状态
      function calculateNextGeneration() {
        let newCellList = {};
        Object.keys(cellList).forEach((key) => {
          const { i, j } = cellList[key];
          let neighbors = countNeighbors(i, j); // 计算邻居数量

          if (neighbors === 2 || neighbors === 3) {
            newCellList[`${i},${j}`] = { i, j }; // 存活的细胞周围邻居少于2个或多于3个，死亡
          }
        });
        Object.keys(deadCell).forEach((key) => {
          if (deadCell[key] === 0 || deadCell[key] === 3) {
            const [i, j] = key.split(',').map((el) => +el);
            newCellList[`${i},${j}`] = { i, j }; // 存活的细胞周围邻居少于2个或多于3个，死亡
          }
        });
        cellList = newCellList;
        createDeadCells();
      }

      // 计算指定位置的细胞周围存活细胞的数量
      function countNeighbors(i, j) {
        let count = 0;
        if (cellList[`${i - 1},${j - 1}`]) {
          count++;
        }
        if (cellList[`${i - 1},${j}`]) {
          count++;
        }
        if (cellList[`${i - 1},${j + 1}`]) {
          count++;
        }
        if (cellList[`${i},${j - 1}`]) {
          count++;
        }
        if (cellList[`${i},${j + 1}`]) {
          count++;
        }
        if (cellList[`${i + 1},${j - 1}`]) {
          count++;
        }
        if (cellList[`${i + 1},${j}`]) {
          count++;
        }
        if (cellList[`${i + 1},${j + 1}`]) {
          count++;
        }

        return count;
      }

      let loop = false;

      // 每秒钟更新一次棋盘
      setInterval(() => {
        if (loop) {
          calculateNextGeneration();
        }
        drawBoard();
      }, 1000 / 60);
      let startX, startY, oldX, oldY;
      let moveFlag = false;
      let downTime = 0;
      canvas.addEventListener('mousedown', (e) => {
        oldX = translateX;
        oldY = translateY;
        startX = e.clientX;
        startY = e.clientY;
        moveFlag = true;
        downTime = Date.now();
      });
      window.addEventListener('mousemove', (e) => {
        if (moveFlag) {
          translateX = oldX + (e.clientX - startX) / Math.pow(2, scale - 1);
          translateY = oldY + (e.clientY - startY) / Math.pow(2, scale - 1);
        }
      });
      canvas.addEventListener('mouseup', (e) => {
        moveFlag = false;
        translateX = oldX + (e.clientX - startX) / Math.pow(2, scale - 1);
        translateY = oldY + (e.clientY - startY) / Math.pow(2, scale - 1);
        if (
          e.clientX - startX === 0 &&
          e.clientY - startY === 0 &&
          Date.now() - downTime < 300
        ) {
          const j = Math.floor(
            (e.clientX - translateX * Math.pow(2, scale - 1)) /
              (cellSize * Math.pow(2, scale - 1))
          );
          const i = Math.floor(
            (e.clientY - translateY * Math.pow(2, scale - 1)) /
              (cellSize * Math.pow(2, scale - 1))
          );
          const key = `${i},${j}`;
          if (cellList[key]) {
            delete cellList[key];
            createDeadCell(i, j, -1);
          } else {
            cellList[key] = { i, j };
            createDeadCell(i, j);
          }
        }
      });
      btn.addEventListener('click', () => {
        loop = !loop;
        btn.innerText = loop ? '暂停' : '开始';
      });
      step.addEventListener('click', () => {
        if (!loop) {
          calculateNextGeneration();
        }
      });
      let scaleFlag = true;
      window.addEventListener('wheel', (e) => {
        if (scaleFlag && e.deltaY !== 0) {
          scaleFlag = false;
          setTimeout(() => {
            scaleFlag = true;
          }, 300);
          if (e.deltaY > 0) {
            scale = Math.min(scale + 1, 4);
          } else {
            scale = Math.max(scale - 1, -10);
          }
          // cellSize = baseSize * Math.pow(2, scale - 1);
        }
      });
    </script>
  </body>
</html>
