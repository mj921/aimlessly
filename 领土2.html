<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    html,
    body {
      padding: 0;
      margin: 0;
    }

    #main {
      position: absolute;
      left: 0;
      height: 0;
      width: 500px;
      height: 500px;
    }
    #data {
      position: absolute;
      right: 10px;
    }
  </style>
</head>

<body>
  <canvas id="main"></canvas>
  <div id="data"></div>
  <script>
    const main = document.getElementById('main');
    const mainCtx = main.getContext('2d');
    const ballCanvas = document.createElement('canvas');
    const ballCtx = ballCanvas.getContext('2d');
    const cellCanvas = document.createElement('canvas');
    const cellCtx = cellCanvas.getContext('2d');
    const dataEl = document.getElementById('data');
    let screenWidth = 500;
    let screenHeight = 500;
    const resizeHandle = () => {
      // screenWidth = window.innerWidth;
      // screenHeight = window.innerHeight;
      main.width = screenWidth;
      main.height = screenHeight;
      ballCanvas.width = screenWidth;
      ballCanvas.height = screenHeight;
      cellCanvas.width = screenWidth;
      cellCanvas.height = screenHeight;
    }
    let time = 0;
    const mapSize = 101;
    const cellSize = 4;
    const ballSpeed = 3;
    const ballSize = 2;
    let mapCells = [];
    let ballList = [];
    const GroupStatus = {
      CREATE_BALL: 1,
      BALL_MOVE: 2,
      END: 3,
    }
    const groupMap = {
      red: {
        type: 'red',
        cellNum: 0,
        maxCellNum: 0,
        minCellNum: 0,
      },
      gold: {
        type: 'gold',
        cellNum: 0,
        maxCellNum: 0,
        minCellNum: 0,
      },
      blue: {
        type: 'blue',
        cellNum: 0,
        maxCellNum: 0,
        minCellNum: 0,
      },
      green: {
        type: 'green',
        cellNum: 0,
        maxCellNum: 0,
        minCellNum: 0,
      }
    }
    const launchPoint = [{
      x: 0,
      y: 0,
      startAngle: 0,
      range: 90,
      status: GroupStatus.CREATE_BALL,
      ballInfo: {},
    }, {
      x: mapSize - 1,
      y: 0,
      startAngle: 90,
      range: 90,
      status: GroupStatus.CREATE_BALL,
      ballInfo: {},
    }, {
      x: 0,
      y: mapSize - 1,
      startAngle: 270,
      range: 90,
      status: GroupStatus.CREATE_BALL,
      ballInfo: {},
    }, {
      x: mapSize - 1,
      y: mapSize - 1,
      startAngle: 180,
      range: 90,
      status: GroupStatus.CREATE_BALL,
      ballInfo: {},
    }, {
      x: Math.floor(mapSize / 4) - 1,
      y: Math.floor(mapSize / 4) - 1,
      startAngle: 0,
      range: 360,
      status: GroupStatus.CREATE_BALL,
      ballInfo: {},
    }, {
      x: Math.floor(mapSize / 4) - 1,
      y: mapSize - (Math.floor(mapSize / 4) - 1),
      startAngle: 0,
      range: 360,
      status: GroupStatus.CREATE_BALL,
      ballInfo: {},
    }, {
      x: mapSize - (Math.floor(mapSize / 4) - 1),
      y: Math.floor(mapSize / 4) - 1,
      startAngle: 0,
      range: 360,
      status: GroupStatus.CREATE_BALL,
      ballInfo: {},
    }, {
      x: mapSize - (Math.floor(mapSize / 4) - 1),
      y: mapSize - (Math.floor(mapSize / 4) - 1),
      startAngle: 0,
      range: 360,
      status: GroupStatus.CREATE_BALL,
      ballInfo: {},
    }, {
      x: (mapSize - 1) / 2,
      y: (mapSize - 1) / 2,
      startAngle: 0,
      range: 360,
      status: GroupStatus.CREATE_BALL,
      ballInfo: {},
    }]
    let maxCellNum = 0;
    let minCellNum = 0;
    const ctxClear = ctx => {
      ctx.clearRect(0, 0, screenWidth, screenHeight);
    }
    const init = () => {
      ctxClear(mainCtx);
      mapCells = [];
      ballList = [];
      const cellNum = Math.pow(((mapSize - 1) / 2), 2);
      maxCellNum = { cellNum, type: '' };
      minCellNum = { cellNum, type: '' };
      Object.keys(groupMap).forEach(key => {
        groupMap[key].cellNum = cellNum;
        groupMap[key].maxCellNum = cellNum;
        groupMap[key].minCellNum = cellNum;
      })
      launchPoint.forEach(point => {
        point.ballInfo = {
          wait: 1,
          total: 1,
        };
      })
      for (let i = 0; i < mapSize; i++) {
        const cells = [];
        for (let j = 0; j < mapSize; j++) {
          let type;
          if (i < (mapSize - 1) / 2) {
            if (j < (mapSize - 1) / 2) {
              type = 'red';
            } else if (j > (mapSize - 1) / 2) {
              type = 'gold';
            }
          } else if (i > (mapSize - 1) / 2) {
            if (j < (mapSize - 1) / 2) {
              type = 'blue';
            } else if (j > (mapSize - 1) / 2) {
              type = 'green';
            }
          }
          const cell = {
            x: j,
            y: i,
            type,
          };
          cells.push(cell);
          drawCell(cell);
          cellCtx.fillStyle = type || 'white';
          cellCtx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
        }
        mapCells.push(cells);
      }
      launchPoint.forEach(point => {
        mapCells[point.y][point.x].isLaunch = true;
        drawCell(mapCells[point.y][point.x]);
      });
      mainCtx.drawImage(cellCanvas, 0, 0);
      createDataHtml();
    }
    const createDataHtml = () => {
      let html = `<div>
          <dl>time: ${time}</dl>
          <dl style="color: ${maxCellNum.type || '#000'}">max: ${maxCellNum.cellNum}</dl>
          <dl style="color: ${minCellNum.type || '#000'}">min: ${minCellNum.cellNum}</dl>
        </div><ul>`;
      const arr = Object.keys(groupMap).map(key => groupMap[key]);
      arr.sort((a, b) => b.cellNum - a.cellNum);
      arr.forEach(({ type, cellNum, maxCellNum: max, minCellNum: min }) => {
        html += `<li style="color: ${type};">
          <dt>${type}ï¼š${cellNum}</dt>
          <dl>max: ${max} min: ${min}</dl>
        </li>`;
      })
      html += '</ul>';
      dataEl.innerHTML = html;
    }

    let raf = null;
    const setMinMax = (key, val) => {
      groupMap[key].maxCellNum = Math.max(groupMap[key].maxCellNum, val);
      groupMap[key].minCellNum = Math.min(groupMap[key].minCellNum, val);
      if (maxCellNum.cellNum < val) {
        maxCellNum = {
          cellNum: val,
          type: key,
        };
      }
      if (minCellNum.cellNum > val) {
        minCellNum = {
          cellNum: val,
          type: key,
        };
      }
    }
    const drawCell = cell => {
      cellCtx.fillStyle = cell.type || 'white';
      cellCtx.fillRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
      if (cell.isLaunch) {
        cellCtx.strokeStyle = 'white';
        cellCtx.strokeRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
      }
    }
    const loop = () => {
      time++;
      ctxClear(mainCtx);
      ctxClear(ballCtx);
      ballCtx.fillStyle = '#000';
      launchPoint.forEach(point => {
        const { position, startAngle, x, y, range } = point;
        const type = mapCells[y][x].type;
        if (!type) return;
        if (point.status === GroupStatus.BALL_MOVE && point.ballInfo.total <= 0) {
          point.status = GroupStatus.CREATE_BALL;
          point.ballInfo = {
            wait: 1,
            total: 1,
          };
        }
        const { ballInfo } = point;
        if (point.status === GroupStatus.CREATE_BALL) {
          const { wait, total } = ballInfo;
          for (let i = 0; i < wait; i++) {
            if (Math.random() < wait / (total * total) * 0.618) {
              ballInfo.wait++;
              ballInfo.total++;
            } else {
              ballInfo.wait--;
            }
          }
          if (ballInfo.wait === 0) {
            let r = Math.random();
            let val = 0.5;
            let bl = 1;
            while (r < val && bl <= 2048) {
              bl *= 2;
              val /= 2;
              r = Math.random() - Math.min(bl / 1000, 0.1);
            }
            ballInfo.total *= Math.pow(2, bl - 1);
            ballInfo.total = Math.min(mapSize * mapSize / 2, ballInfo.total);
            point.status = GroupStatus.BALL_MOVE;
            const ballNum = ballInfo.total;
            for (let i = 0; i < ballNum; i++) {
              ballList.push({
                x: (x + 0.5) * cellSize,
                y: (y + 0.5) * cellSize,
                angle: startAngle + Math.floor(Math.random() * range),
                type,
                launchPoint: point,
                time: 0,
              })
            }
          }
        }
      })
      for (let i = 0; i < ballList.length;) {
        const ball = ballList[i];
        ball.time++;
        ball.x += Math.cos(ball.angle * Math.PI / 180) * ballSpeed;
        ball.y += Math.sin(ball.angle * Math.PI / 180) * ballSpeed;
        const { x, y } = ball;
        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        let collisionCell = null;
        if (cellX < 0) {
          ball.angle = ball.angle > 180 ? (540 - ball.angle) : (180 - ball.angle);
        } else if(cellX > mapSize - 1) {
          ball.angle = ball.angle > 180 ? (540 - ball.angle) : (180 - ball.angle);
        } else if(cellY < 0) {
          ball.angle = (ball.angle > 180 ? 360 : 180) - ball.angle;
        } else if(cellY > mapSize - 1) {
          ball.angle = (ball.angle > 180 ? 180 : 360) - ball.angle;
        } else if (mapCells[cellY][cellX].type !== ball.type) {
          collisionCell = mapCells[cellY][cellX];
        } else if (cellX > 0 && x % cellSize <= ballSize) {
          collisionCell = mapCells[cellY][cellX - 1];
        } else if (cellY > 0 && y % cellSize <= ballSize) {
          collisionCell = mapCells[cellY - 1][cellX];
        } else if ((x + ballSize) / cellSize >= cellX) {
          collisionCell = mapCells[cellY][cellX + 1];
        } else if ((y + ballSize) / cellSize >= cellY) {
          collisionCell = mapCells[cellY + 1][cellX];
        }
        ball.angle %= 360;
        if (collisionCell && collisionCell.type !== ball.type) {
          collisionCell.type && groupMap[collisionCell.type].cellNum--;
          groupMap[ball.type].cellNum++;
          collisionCell.type && setMinMax(collisionCell.type, groupMap[collisionCell.type].cellNum)
          setMinMax(ball.type, groupMap[ball.type].cellNum)
          collisionCell.type = ball.type;
          drawCell(collisionCell);
          ballList.splice(i, 1);
          ball.launchPoint.ballInfo.total--;
          continue;
        }
        if (ball.time > 1000) {
          ballList.splice(i, 1);
          ball.launchPoint.ballInfo.total--;
          continue;
        }
        ballCtx.beginPath();
        ballCtx.arc(ball.x, ball.y, ballSize, 0, 180);
        ballCtx.fill();
        i++;
      }
      mainCtx.drawImage(cellCanvas, 0, 0);
      mainCtx.drawImage(ballCanvas, 0, 0);
      createDataHtml();
      raf = requestAnimationFrame(loop);
    }
    resizeHandle();
    init();
    loop();
  </script>
</body>

</html>