<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>粒子时钟</title>
    <link rel="stylesheet" href="" />
    <style>
      body {
        margin: 0;
      }
      #canvas1,
      #canvas2 {
        position: absolute;
        left: -1000%;
        top: -1000%;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="800" height="800"></canvas>
    <canvas id="canvas1" width="800" height="800"></canvas>
    <canvas id="canvas2" width="800" height="800"></canvas>
    <script>
      let width = window.innerWidth;
      let height = window.innerHeight;
      let size = Math.min(width, height);
      let fontSize = ((size - 100) / 250) * 50;
      let canvas = document.getElementById('canvas');
      let canvas1 = document.getElementById('canvas1');
      let canvas2 = document.getElementById('canvas2');
      const textConfig = [-1.93, -1.23, -0.79, -0.35, 0.35, 0.79, 1.23, 1.93];
      const textCanvasConfig = [0.6, 0.6, 0.28, 0.6, 0.6, 0.28, 0.6, 0.6];
      let beforeText = [];
      const setSize = () => {
        size = Math.floor(Math.min(width, height));
        canvas.width = width;
        canvas.height = height;
        canvas1.width = size;
        canvas1.height = size;
        canvas2.width = size;
        canvas2.height = size;
        fontSize = ((size - 100) / 250) * 50;
      };
      setSize();
      let ctx = canvas.getContext('2d');
      let ctx1 = canvas1.getContext('2d');
      let ctx2 = canvas2.getContext('2d');
      window.addEventListener('resize', () => {
        width = window.innerWidth;
        height = window.innerHeight;
        size = Math.min(width, height);
        setSize();
      });
      let particleList = [];
      function Particle({ x, y, color, v, to, from, fromParticle }) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.from = from;
        this.to = to;
        this.v = v;
        this.fromParticle = fromParticle;
        this.status = 'to';
      }
      Particle.prototype.move = function () {
        const { x: toX, y: toY } = this.to;
        const { x: fromX, y: fromY } = this.from;
        const x = this.status === 'to' ? toX - fromX : fromX - toX;
        const y = this.status === 'to' ? toY - fromY : fromY - toY;
        // const moveX = (x / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))) * this.v;
        // const moveY = (y / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))) * this.v;
        const moveX = x / this.v;
        const moveY = y / this.v;
        if (
          this.status === 'to' &&
          ((x !== 0 && Math.abs(moveX) > Math.abs(toX - this.x)) ||
            (y !== 0 && Math.abs(moveY) > Math.abs(toY - this.y)))
        ) {
          this.status = 'from';
          this.x = toX;
          this.y = toY;
        } else if (
          this.status === 'from' &&
          ((x !== 0 && Math.abs(moveX) > Math.abs(fromX - this.x)) ||
            (y !== 0 && Math.abs(moveY) > Math.abs(fromY - this.y)))
        ) {
          particleList[this.fromParticle.i] = this.fromParticle;
        } else {
          this.x += moveX;
          this.y += moveY;
        }
      };
      Particle.prototype.draw = function () {
        const { color, x, y } = this;
        ctx1.fillStyle = color;
        ctx1.beginPath();
        ctx1.arc(x, y, 2, 0, Math.PI * 2);
        ctx1.closePath();
        ctx1.fill();
      };
      Particle.prototype.isRingParticle = () => false;
      function RingParticle({ a, r, color, v, i }) {
        this.a = a;
        this.r = r;
        this.color = color;
        this.v = v;
        this.i = i;
      }
      RingParticle.prototype.move = function () {
        this.a = (this.a + this.v) % 360;
      };
      RingParticle.prototype.draw = function () {
        const { color, r, a } = this;
        ctx1.fillStyle = color;
        ctx1.beginPath();
        ctx1.arc(
          size / 2 + r * Math.cos((Math.PI * 2 * a) / 360),
          size / 2 + r * Math.sin((Math.PI * 2 * a) / 360),
          2,
          0,
          Math.PI * 2
        );
        ctx1.closePath();
        ctx1.fill();
      };
      RingParticle.prototype.isRingParticle = () => true;
      RingParticle.prototype.toParticle = function (to) {
        const { color, r, a, v } = this;
        const x = size / 2 + r * Math.cos((Math.PI * 2 * a) / 360);
        const y = size / 2 + r * Math.sin((Math.PI * 2 * a) / 360);
        return new Particle({
          x,
          y,
          color,
          // v: (Math.PI * 2 * r * v) / 360,
          v: 15 + 10 * Math.random(),
          to,
          from: {
            x,
            y,
          },
          fromParticle: this,
        });
      };
      // Particle.prototype.
      const particleNum = 700;
      const init = () => {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);
        particleList = [];
        for (let i = 0; i < particleNum; i++) {
          particleList.push(
            new RingParticle({
              a: Math.random() * 360,
              r: size / 2 - 60 + 30 * Math.random(),
              color: `#${('00000' + Math.floor(16777216 * Math.random()).toString(16)).slice(-6)}`,
              v: 0.5 + Math.random(),
              i,
            })
          );
        }
      };
      const translateParticle = () => {};
      const drawBg = () => {
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.fillRect(0, 0, width, height);
      };
      const drawBg1 = () => {
        ctx1.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx1.beginPath();
        ctx1.fillRect(0, 0, width, height);
      };
      const drawText = () => {
        // ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
        const now = new Date();
        const text = `${('0' + now.getHours()).slice(-2)}:${(
          '0' + now.getMinutes()
        ).slice(-2)}:${('0' + now.getSeconds()).slice(-2)}`;

        ctx2.font = `${fontSize}px 微软雅黑`;
        ctx2.fillStyle = '#fff';
        ctx2.beginPath();
        ctx2.textAlign = 'center';
        ctx2.textBaseline = 'middle';
        text.split('').forEach((el, i) => {
          if (beforeText[i] !== el) {
            const sub = el === ':' ? 0.14 : 0.3;
            ctx2.clearRect(
              Math.floor(size / 2 + (textConfig[i] - sub) * fontSize),
              Math.floor(size / 2 - 0.55 * fontSize),
              sub * 2 * fontSize,
              1.1 * fontSize
            );
            ctx2.fillText(el, size / 2 + textConfig[i] * fontSize, size / 2);
          }
        });
        const imgData = ctx2.getImageData(0, 0, size, size).data;
        let textCicleSize = Math.floor(Math.max(fontSize / 20, 4));
        const list = [];
        text.split('').forEach((el, ii) => {
          if (beforeText[ii] !== el) {
            const sub = el === ':' ? 0.14 : 0.3;
            for (
              let x = Math.floor(size / 2 + (textConfig[ii] - sub) * fontSize),
                xLen = Math.floor(size / 2 + (textConfig[ii] + sub) * fontSize),
                y = Math.floor(size / 2 - 0.55 * fontSize),
                yLen = Math.floor(size / 2 + 0.55 * fontSize);
              x < xLen && y < yLen;

            ) {
              let sum = 0;
              for (let i = 0, j = 0; i < textCicleSize && j < textCicleSize; ) {
                sum += [0, 1, 2].reduce(
                  (s, n) =>
                    s + (imgData[((y + j) * size + (x + i)) * 4 + n] ?? 0),
                  0
                );
                if (i + 1 >= textCicleSize) {
                  i = 0;
                  j++;
                } else {
                  i++;
                }
              }
              if (
                sum /
                  Math.floor(textCicleSize) /
                  Math.floor(textCicleSize) /
                  3 >
                0
              ) {
                list.push({ y, x });
              }
              if (x + textCicleSize >= xLen) {
                x = Math.floor(size / 2 + (textConfig[ii] - sub) * fontSize);
                y += textCicleSize;
              } else {
                x += textCicleSize;
              }
            }

            ctx2.beginPath();
            ctx2.clearRect(
              Math.floor(size / 2 + (textConfig[ii] - sub) * fontSize),
              Math.floor(size / 2 - 0.55 * fontSize),
              sub * 2 * fontSize,
              1.1 * fontSize
            );
          }
        });
        let pI = 0;
        list.forEach(({ x, y }) => {
          ctx2.beginPath();
          ctx2.fillStyle = '#fff';
          ctx2.arc(
            x + (textCicleSize / 2) * 0.8,
            y + (textCicleSize / 2) * 0.8,
            (textCicleSize / 2) * 0.8,
            0,
            Math.PI * 2
          );
          ctx2.fill();
          if (beforeText[0]) {
            let flag = particleList[pI]
              ? particleList[pI].isRingParticle()
              : false;
            while (pI < particleNum - 1 && !flag) {
              pI++;
              flag = particleList[pI].isRingParticle();
            }
            if (pI < particleNum && flag) {
              particleList[pI] = particleList[pI].toParticle({
                x: x + (textCicleSize / 2) * 0.8,
                y: y + (textCicleSize / 2) * 0.8,
              });
            }
          }
        });
        beforeText = text.split('');
      };
      const draw = () => {
        drawBg();
        drawBg1();
        particleList.forEach((el) => {
          el.move();
          el.draw();
        });
        ctx.drawImage(
          canvas1,
          (width - size) / 2,
          (height - size) / 2,
          size,
          size
        );
        drawText();
        ctx.drawImage(
          canvas2,
          (width - canvas2.width) / 2,
          (height - canvas2.height) / 2,
          canvas2.width,
          canvas2.height
        );
      };
      init();
      let sto = null;
      const animate = () => {
        const now = new Date().getTime();
        if (sto) {
          clearTimeout(sto);
        }
        draw();
        sto = setTimeout(animate, Math.max(20 - new Date().getTime() + now, 0));
      };
      animate();
    </script>
  </body>
</html>
