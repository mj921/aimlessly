<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    html,
    body {
      padding: 0;
      margin: 0;
    }

    #main {
      position: absolute;
      left: 0;
      height: 0;
      width: 500px;
      height: 500px;
    }
    #data {
      position: absolute;
      right: 10px;
    }
  </style>
</head>

<body>
  <canvas id="main"></canvas>
  <div id="data"></div>
  <script>
    const main = document.getElementById('main');
    const mainCtx = main.getContext('2d');
    const ballCanvas = document.createElement('canvas');
    const ballCtx = ballCanvas.getContext('2d');
    const cellCanvas = document.createElement('canvas');
    const cellCtx = cellCanvas.getContext('2d');
    const dataEl = document.getElementById('data');
    let screenWidth = 700;
    let screenHeight = 700;
    const resizeHandle = () => {
      main.width = screenWidth;
      main.height = screenHeight;
      ballCanvas.width = screenWidth;
      ballCanvas.height = screenHeight;
      cellCanvas.width = screenWidth;
      cellCanvas.height = screenHeight;
    }
    let time = 0;
    const mapSize = 301;
    const cellSize = 2;
    const ballSpeed = 3;
    const ballSize = 1;
    let mapCells = [];
    let ballList = [];
    const GroupStatus = {
      CREATE_BALL: 1,
      BALL_MOVE: 2,
      END: 3,
    }
    const groupList = ['red', 'blue', 'green', 'yellow'];
    let groupMap = {}
    let launchPoint = []
    let maxCellNum = { cellNum: 0, type: '' };
    let minCellNum = { cellNum: 0, type: '' };
    let maxBallNum = { ballNum: 0, type: '' };
    let maxTotalNum = 0;
    const ctxClear = ctx => {
      ctx.clearRect(0, 0, screenWidth, screenHeight);
    }
    const getRandomCell = isEmpty => {
      let x = Math.floor(Math.random() * mapSize);
      let y = Math.floor(Math.random() * mapSize);
      if (isEmpty(mapCells[x][y])) {
        return mapCells[x][y];
      } else {
        return getRandomCell(isEmpty);
      }
    }
    const init = () => {
      ctxClear(mainCtx);
      mapCells = [];
      ballList = [];
      const cellNum = 1;
      maxCellNum = { cellNum, type: '' };
      minCellNum = { cellNum, type: '' };
      for (let i = 0; i < mapSize; i++) {
        const cells = [];
        for (let j = 0; j < mapSize; j++) {
          const cell = {
            x: j,
            y: i,
            type: '',
          };
          cells.push(cell);
          drawCell(cell);
        }
        mapCells.push(cells);
      }
      launchPoint = [];
      const launchPointNum = 12;
      groupMap = {};
      groupList.forEach(key => {
        groupMap[key] = {
          type: key,
          cellNum: cellNum,
          maxCellNum: cellNum,
          minCellNum: cellNum,
          launchPointNum: 1,
          time: 0,
          launchPointTime: 0,
        };
        const cellItem = getRandomCell(randomCell => randomCell.type === '');
        cellItem.type = key;
        cellItem.isLaunch = true;
        launchPoint.push({
          x: cellItem.x,
          y: cellItem.y,
          startAngle: 0,
          range: 360,
          status: GroupStatus.CREATE_BALL,
          ballInfo: {
            wait: 1,
            total: 1,
          },
        });
        drawCell(cellItem);
      })
      for (let i = 4; i < launchPointNum; i++) {
        const cellItem = getRandomCell(randomCell => !randomCell.launchPoint);
        cellItem.isLaunch = true;
        launchPoint.push({
          x: cellItem.x,
          y: cellItem.y,
          startAngle: 0,
          range: 360,
          status: GroupStatus.CREATE_BALL,
          ballInfo: {
            wait: 1,
            total: 1,
          },
        });
      }
      mainCtx.drawImage(cellCanvas, 0, 0);
      createDataHtml();
    }
    const createDataHtml = () => {
      let html = `<div>
          <dl>time: ${time}</dl>
          <dl style="color: ${maxCellNum.type || '#000'}">max: ${maxCellNum.cellNum}</dl>
          <dl style="color: ${minCellNum.type || '#000'}">min: ${minCellNum.cellNum}</dl>
          <dl style="color: ${maxBallNum.type || '#000'}">maxBall: ${maxBallNum.ballNum}, bl：${maxBallNum.bl}</dl>
          <dl>max: ${maxTotalNum}</dl>
        </div><ul>`;
      const arr = Object.keys(groupMap).map(key => groupMap[key]);
      arr.sort((a, b) => b.cellNum - a.cellNum);
      arr.forEach(({ type, cellNum, maxCellNum: max, minCellNum: min, launchPointNum, time, launchPointTime }) => {
        html += `<li style="color: ${type};">
          <dt>${type}：${cellNum}， ${launchPointNum}</dt>
          <dl>max: ${max} time: ${time} lpTime: ${launchPointTime}</dl>
        </li>`;
      })
      html += '</ul>';
      dataEl.innerHTML = html;
    }

    let raf = null;
    const setMinMax = (key, val) => {
      groupMap[key].maxCellNum = Math.max(groupMap[key].maxCellNum, val);
      groupMap[key].minCellNum = Math.min(groupMap[key].minCellNum, val);
      if (maxCellNum.cellNum < val) {
        maxCellNum = {
          cellNum: val,
          type: key,
        };
      }
      if (minCellNum.cellNum > val) {
        minCellNum = {
          cellNum: val,
          type: key,
        };
      }
    }
    const drawCell = cell => {
      cellCtx.fillStyle = cell.type || 'white';
      cellCtx.fillRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
      if (cell.isLaunch) {
        cellCtx.strokeStyle = 'black';
        cellCtx.strokeRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
      }
    }
    const loop = () => {
      time++;
      ctxClear(mainCtx);
      ctxClear(ballCtx);
      ballCtx.fillStyle = '#000';
      Object.keys(groupMap).forEach(key => {
        if (groupMap[key].cellNum > 0) {
          groupMap[key].time++;
        }
        if (groupMap[key].launchPointNum > 0) {
          groupMap[key].launchPointTime++;
        }
      });
      launchPoint.forEach(point => {
        const { position, startAngle, x, y, range } = point;
        const type = mapCells[y][x].type;
        if (!type) return;
        if (point.status === GroupStatus.BALL_MOVE && point.ballInfo.total <= 0) {
          point.status = GroupStatus.CREATE_BALL;
          point.ballInfo = {
            wait: 1,
            total: 1,
          };
        }
        const { ballInfo } = point;
        if (point.status === GroupStatus.CREATE_BALL) {
          const { wait, total } = ballInfo;
          for (let i = 0; i < wait; i++) {
            if (Math.random() < wait / (total * total) * 0.618) {
              ballInfo.wait++;
              ballInfo.total++;
            } else {
              ballInfo.wait--;
            }
          }
          if (ballInfo.wait === 0) {
            let r = Math.random();
            let val = 0.5;
            let bl = 1;
            while (r < val && bl <= 1024) {
              bl *= 2;
              val /= 2;
              r = Math.random() - Math.min(bl / 1000, 0.1);
            }
            ballInfo.total *= Math.pow(2, bl - 1);
            if (maxBallNum.ballNum < ballInfo.total) {
              maxBallNum = {
                ballNum: ballInfo.total,
                bl,
                type,
              };
            }
            ballInfo.total = Math.min(Math.floor(10000 / launchPoint.length) * 4, ballInfo.total);
            point.status = GroupStatus.BALL_MOVE;
            const ballNum = ballInfo.total;
            for (let i = 0; i < ballNum; i++) {
              ballList.push({
                x: (x + 0.5) * cellSize,
                y: (y + 0.5) * cellSize,
                angle: startAngle + Math.random() * range,
                type,
                launchPoint: point,
                time: 0,
              })
            }
          }
        }
      });

      maxTotalNum = Math.max(maxTotalNum, ballList.length);

      for (let i = 0; i < ballList.length;) {
        const ball = ballList[i];
        ball.time++;
        ball.x += Math.cos(ball.angle * Math.PI / 180) * ballSpeed;
        ball.y += Math.sin(ball.angle * Math.PI / 180) * ballSpeed;
        const { x, y } = ball;
        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        let collisionCell = null;
        if (cellX < 0) {
          ball.angle = ball.angle > 180 ? (540 - ball.angle) : (180 - ball.angle);
        } else if(cellX > mapSize - 1) {
          ball.angle = ball.angle > 180 ? (540 - ball.angle) : (180 - ball.angle);
        } else if(cellY < 0) {
          ball.angle = (ball.angle > 180 ? 360 : 180) - ball.angle;
        } else if(cellY > mapSize - 1) {
          ball.angle = (ball.angle > 180 ? 180 : 360) - ball.angle;
        } else if (mapCells[cellY][cellX].type !== ball.type) {
          collisionCell = mapCells[cellY][cellX];
        } else if (cellX > 0 && x % cellSize <= ballSize) {
          collisionCell = mapCells[cellY][cellX - 1];
        } else if (cellY > 0 && y % cellSize <= ballSize) {
          collisionCell = mapCells[cellY - 1][cellX];
        } else if ((x + ballSize) / cellSize >= cellX) {
          collisionCell = mapCells[cellY][cellX + 1];
        } else if ((y + ballSize) / cellSize >= cellY) {
          collisionCell = mapCells[cellY + 1][cellX];
        }
        ball.angle %= 360;
        if (collisionCell && collisionCell.type !== ball.type) {
          if (collisionCell.type) {
            groupMap[collisionCell.type].cellNum--;
            setMinMax(collisionCell.type, groupMap[collisionCell.type].cellNum);
          };
          if (collisionCell.isLaunch) {
            collisionCell.type && groupMap[collisionCell.type].launchPointNum--;
            groupMap[ball.type].launchPointNum++;
          }
          groupMap[ball.type].cellNum++;
          setMinMax(ball.type, groupMap[ball.type].cellNum)
          collisionCell.type = ball.type;
          drawCell(collisionCell);
          ballList.splice(i, 1);
          ball.launchPoint.ballInfo.total--;
          continue;
        }
        if (ball.time > 1000) {
          ballList.splice(i, 1);
          ball.launchPoint.ballInfo.total--;
          continue;
        }
        ballCtx.beginPath();
        ballCtx.arc(ball.x, ball.y, ballSize, 0, 180);
        ballCtx.fill();
        i++;
      }
      mainCtx.drawImage(cellCanvas, 0, 0);
      mainCtx.drawImage(ballCanvas, 0, 0);
      createDataHtml();
      raf = requestAnimationFrame(loop);
    }
    resizeHandle();
    init();
    loop();
  </script>
</body>

</html>