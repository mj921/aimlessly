<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script src="./index.js"></script>
    <script src="./Vector2.js"></script>
    <script src="./Vector3.js"></script>
    <script src="./modelJson.js"></script>
    <script>
      const scale = 500;
      const scene = new Scene({
        width: scale,
        height: scale,
      });
      const fillSJX1 = (p0, p1, p2) => {
        const arrY = [p0, p1, p2];
        arrY.sort((a, b) => a.y - b.y);
        [p0, p1, p2] = arrY;
        const step0 = (p2.x - p0.x) / (p2.y - p0.y);
        const step1 = (p1.x - p0.x) / (p1.y - p0.y);
        const step2 = (p2.x - p1.x) / (p2.y - p1.y);
        let prev0 = p0.x;
        let prev1 = p0.x;
        let prev2 = p1.x;
        // p0p1 是否比 p0p2斜率更大
        for (let i = p0.y; i < p1.y; i++) {
          prev0 += step0;
          prev1 += step1;
          let x1 = prev0;
          let x2 = prev1;
          if (x1 > x2) {
            [x1, x2] = [x2, x1];
          }
          for (let j = x1; j <= x2; j++) {
            scene.add({
              x: j,
              y: i,
            });
          }
        }

        for (let i = p1.y; i < p2.y; i++) {
          prev0 += step0;
          prev2 += step2;
          let x1 = prev0;
          let x2 = prev2;
          if (x1 > x2) {
            [x1, x2] = [x2, x1];
          }
          for (let j = x1; j <= x2; j++) {
            scene.add({
              x: j,
              y: i,
            });
          }
        }
      };
      // fillSJX1({ x: 65, y: 5 }, { x: 3, y: 37 }, { x: 7, y: 10 });
      const fillSJX = (points) => {
        const len = points.length;
        const xs = [];
        const ys = [];
        const sides = [];
        for (let i = 0; i < len; i++) {
          xs[i] = points[i].x;
          ys[i] = points[i].y;
          sides[i] = {
            x: points[(i + 1) % len].x - points[i].x,
            y: points[(i + 1) % len].y - points[i].y,
          };
        }
        const minX = Math.max(0, Math.min.apply(null, xs));
        const maxX = Math.min(scale - 1, Math.max.apply(null, xs));
        const minY = Math.max(0, Math.min.apply(null, ys));
        const maxY = Math.min(scale - 1, Math.max.apply(null, ys));
        for (let i = minX; i <= maxX; i++) {
          for (let j = minY; j <= maxY; j++) {
            let result = 0;
            for (let k = 0; k < len; k++) {
              const r =
                (i - points[k].x) * sides[k].y - (j - points[k].y) * sides[k].x;
              result += r > 0 ? 1 : r < 0 ? -1 : r;
            }
            if (result === len || result === -len) {
              scene.add({
                x: i,
                y: j,
              });
            }
          }
        }
      };

      /** 叉乘判断角度 都是一个方向 */
      // fillSJX([
      //   { x: 65, y: 5 },
      //   { x: 3, y: 37 },
      //   { x: 7, y: 10 },
      // ]);
      const barycentric = (pts, p) => {
        const p1 = new Vector3(
          pts[1].x - pts[0].x,
          pts[2].x - pts[0].x,
          pts[0].x - p.x
        );
        const p2 = new Vector3(
          pts[1].y - pts[0].y,
          pts[2].y - pts[0].y,
          pts[0].y - p.y
        );
        const u = p1.cross(p2);
        if (Math.abs(u.z) < 1) return { x: -1, y: 1, z: 1 };
        return { x: 1 - (u.x + u.y) / u.z, y: u.x / u.z, z: u.y / u.z };
      };
      /** 重心法 */
      const fillSJXZX = (points, color) => {
        const len = points.length;
        const xs = [];
        const ys = [];
        const sides = [];
        for (let i = 0; i < len; i++) {
          xs[i] = points[i].x;
          ys[i] = points[i].y;
          sides[i] = {
            x: points[(i + 1) % len].x - points[i].x,
            y: points[(i + 1) % len].y - points[i].y,
          };
        }
        const minX = Math.floor(Math.max(0, Math.min.apply(null, xs)));
        const maxX = Math.min(scale - 1, Math.max.apply(null, xs));
        const minY = Math.floor(Math.max(0, Math.min.apply(null, ys)));
        const maxY = Math.min(scale - 1, Math.max.apply(null, ys));
        for (let i = minX; i <= maxX; i++) {
          for (let j = minY; j <= maxY; j++) {
            const result = barycentric(points, { x: i, y: j });
            if (result.x < 0 || result.y < 0 || result.z < 0) {
              continue;
            }
            scene.add({
              x: i,
              y: j,
              color,
            });
          }
        }
      };

      console.time();
      for (let index = 0; index < modelJson.f.length; index++) {
        const v1 = new Vector3(
          modelJson.v[modelJson.f[index][1][0]][0] -
            modelJson.v[modelJson.f[index][0][0]][0],
          modelJson.v[modelJson.f[index][1][0]][1] -
            modelJson.v[modelJson.f[index][0][0]][1],
          modelJson.v[modelJson.f[index][1][0]][2] -
            modelJson.v[modelJson.f[index][0][0]][2]
        );
        const v2 = new Vector3(
          modelJson.v[modelJson.f[index][2][0]][0] -
            modelJson.v[modelJson.f[index][0][0]][0],
          modelJson.v[modelJson.f[index][2][0]][1] -
            modelJson.v[modelJson.f[index][0][0]][1],
          modelJson.v[modelJson.f[index][2][0]][2] -
            modelJson.v[modelJson.f[index][0][0]][2]
        );
        const intensity = v2.cross(v1).normalize().dot(new Vector3(0, 0, -1));
        if (intensity <= 0) continue;
        const color = [
          Math.floor(255 * intensity),
          Math.floor(255 * intensity),
          Math.floor(255 * intensity),
          255,
        ];
        fillSJXZX(
          [
            {
              x:
                ((modelJson.v[modelJson.f[index][0][0]][0] + 1) / 2) *
                scale,
              y:
                (1 - (modelJson.v[modelJson.f[index][0][0]][1] + 1) / 2) *
                scale,
            },
            {
              x:
                ((modelJson.v[modelJson.f[index][1][0]][0] + 1) / 2) *
                scale,
              y:
                (1 - (modelJson.v[modelJson.f[index][1][0]][1] + 1) / 2) *
                scale,
            },
            {
              x:
                ((modelJson.v[modelJson.f[index][2][0]][0] + 1) / 2) *
                scale,
              y:
                (1 - (modelJson.v[modelJson.f[index][2][0]][1] + 1) / 2) *
                scale,
            },
          ],
          color
        );
      }
      console.timeEnd();
      console.time('render');
      scene.render();
      console.timeEnd('render');
    </script>
  </body>
</html>
